---
phase: 09-dropbox-export
plan: 01
type: execute
---

<objective>
Set up Dropbox integration with OAuth2 PKCE authentication and encrypted file upload.

Purpose: Enable secure, encrypted backup uploads to Dropbox using the official SDK and OAuth2 PKCE flow for mobile apps.
Output: Working Dropbox OAuth flow and upload functionality via service layer.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-phase.md
./.claude/get-shit-done/templates/summary.md
./.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-dropbox-export/DISCOVERY.md
@src/features/backup/backup-service.ts
@src/lib/garmin/auth.ts
@src/lib/garmin/client.ts
@capacitor.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create Dropbox service structure</name>
  <files>package.json, src/lib/dropbox/types.ts, src/lib/dropbox/constants.ts, src/lib/dropbox/index.ts</files>
  <action>
1. Install dependencies:
   ```bash
   npm install dropbox @capacitor-community/generic-oauth2
   npx cap sync
   ```

2. Create `src/lib/dropbox/types.ts`:
   - DropboxTokens interface (accessToken, refreshToken, expiresAt)
   - DropboxExportResult interface (success, path, timestamp, error?)
   - DropboxConnectionStatus interface (isConnected, accountEmail?, lastExport?)

3. Create `src/lib/dropbox/constants.ts`:
   - DROPBOX_APP_KEY placeholder (user must create app at dropbox.com/developers)
   - DROPBOX_AUTH_URL: 'https://www.dropbox.com/oauth2/authorize'
   - DROPBOX_TOKEN_URL: 'https://api.dropboxapi.com/oauth2/token'
   - DROPBOX_BACKUP_PATH: '/MigraineTracker/backup.enc'
   - DROPBOX_SCOPES: 'files.content.write files.content.read'

4. Create `src/lib/dropbox/index.ts` barrel export.

Note: App key is a placeholder - user will need to create their own Dropbox app and configure the key. Include comment explaining this.
  </action>
  <verify>npm run build passes, new files exist in src/lib/dropbox/</verify>
  <done>Dependencies installed, types and constants defined, no TypeScript errors</done>
</task>

<task type="auto">
  <name>Task 2: Implement Dropbox OAuth2 authentication service</name>
  <files>src/lib/dropbox/auth.ts, android/app/src/main/AndroidManifest.xml</files>
  <action>
1. Create `src/lib/dropbox/auth.ts` following garmin/auth.ts pattern:

```typescript
import { GenericOAuth2 } from '@capacitor-community/generic-oauth2';
import { Preferences } from '@capacitor/preferences';
import { Capacitor } from '@capacitor/core';
import { DROPBOX_APP_KEY, DROPBOX_AUTH_URL, DROPBOX_TOKEN_URL, DROPBOX_SCOPES } from './constants';
import type { DropboxTokens } from './types';

const TOKENS_KEY = 'dropbox_tokens';

export async function authenticateDropbox(): Promise<DropboxTokens> {
  const options = {
    appId: DROPBOX_APP_KEY,
    authorizationBaseUrl: DROPBOX_AUTH_URL,
    accessTokenEndpoint: DROPBOX_TOKEN_URL,
    responseType: 'code',
    pkceEnabled: true,
    scope: DROPBOX_SCOPES,
    additionalParameters: {
      token_access_type: 'offline' // Request refresh token
    },
    web: {
      redirectUrl: window.location.origin + '/callback',
    },
    android: {
      redirectUrl: 'com.example.migrainetracker://oauth/callback',
    }
  };

  const result = await GenericOAuth2.authenticate(options);

  const tokens: DropboxTokens = {
    accessToken: result['access_token'],
    refreshToken: result['refresh_token'] || null,
    expiresAt: result['expires_in']
      ? Date.now() + (result['expires_in'] * 1000)
      : null
  };

  await saveTokens(tokens);
  return tokens;
}

export async function refreshDropboxToken(): Promise<DropboxTokens | null> {
  const tokens = await getTokens();
  if (!tokens?.refreshToken) return null;

  try {
    const result = await GenericOAuth2.refreshToken({
      appId: DROPBOX_APP_KEY,
      accessTokenEndpoint: DROPBOX_TOKEN_URL,
      refreshToken: tokens.refreshToken
    });

    const newTokens: DropboxTokens = {
      accessToken: result['access_token'],
      refreshToken: result['refresh_token'] || tokens.refreshToken,
      expiresAt: result['expires_in']
        ? Date.now() + (result['expires_in'] * 1000)
        : null
    };

    await saveTokens(newTokens);
    return newTokens;
  } catch {
    return null;
  }
}

export async function getTokens(): Promise<DropboxTokens | null> {
  const { value } = await Preferences.get({ key: TOKENS_KEY });
  return value ? JSON.parse(value) : null;
}

export async function saveTokens(tokens: DropboxTokens): Promise<void> {
  await Preferences.set({ key: TOKENS_KEY, value: JSON.stringify(tokens) });
}

export async function clearTokens(): Promise<void> {
  await Preferences.remove({ key: TOKENS_KEY });
}

export async function getValidAccessToken(): Promise<string | null> {
  const tokens = await getTokens();
  if (!tokens) return null;

  // Check if token is expired (with 5 min buffer)
  if (tokens.expiresAt && tokens.expiresAt < Date.now() + 300000) {
    const refreshed = await refreshDropboxToken();
    return refreshed?.accessToken || null;
  }

  return tokens.accessToken;
}

export function isWebDev(): boolean {
  return !Capacitor.isNativePlatform();
}
```

2. Update Android manifest to handle OAuth callback. Add inside <activity> for MainActivity:
```xml
<intent-filter>
    <action android:name="android.intent.action.VIEW" />
    <category android:name="android.intent.category.DEFAULT" />
    <category android:name="android.intent.category.BROWSABLE" />
    <data android:scheme="com.example.migrainetracker" android:host="oauth" android:path="/callback" />
</intent-filter>
```
  </action>
  <verify>npm run build passes, auth.ts compiles without errors</verify>
  <done>OAuth2 PKCE auth functions implemented, Android manifest updated for deep linking</done>
</task>

<task type="auto">
  <name>Task 3: Implement Dropbox client with encrypted upload</name>
  <files>src/lib/dropbox/client.ts, src/lib/dropbox/index.ts</files>
  <action>
1. Create `src/lib/dropbox/client.ts`:

```typescript
import { Dropbox } from 'dropbox';
import { db } from '@/lib/db';
import { format } from 'date-fns';
import type { BackupData } from '@/features/backup/backup-service';
import {
  authenticateDropbox,
  getValidAccessToken,
  clearTokens,
  getTokens
} from './auth';
import { DROPBOX_BACKUP_PATH } from './constants';
import type { DropboxConnectionStatus, DropboxExportResult } from './types';

// Note: Using backup-service's encryption pattern but simplified for Dropbox
// We store the encrypted JSON directly, no need for the full EncryptedBackup wrapper

async function encryptData(data: string, password: string): Promise<{ iv: string; data: string }> {
  const encoder = new TextEncoder();
  const passwordBuffer = encoder.encode(password);
  const passwordHash = await crypto.subtle.digest('SHA-256', passwordBuffer);

  const key = await crypto.subtle.importKey(
    'raw',
    passwordHash,
    { name: 'AES-GCM' },
    false,
    ['encrypt']
  );

  const iv = crypto.getRandomValues(new Uint8Array(12));
  const dataBuffer = encoder.encode(data);
  const encryptedBuffer = await crypto.subtle.encrypt(
    { name: 'AES-GCM', iv },
    key,
    dataBuffer
  );

  return {
    iv: arrayBufferToBase64(iv.buffer),
    data: arrayBufferToBase64(encryptedBuffer),
  };
}

function arrayBufferToBase64(buffer: ArrayBuffer): string {
  const bytes = new Uint8Array(buffer);
  let binary = '';
  for (let i = 0; i < bytes.byteLength; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}

class DropboxClient {
  private lastExportTimestamp: string | null = null;

  async connect(): Promise<void> {
    await authenticateDropbox();
  }

  async disconnect(): Promise<void> {
    await clearTokens();
    this.lastExportTimestamp = null;
  }

  async getConnectionStatus(): Promise<DropboxConnectionStatus> {
    const tokens = await getTokens();
    const accessToken = await getValidAccessToken();

    if (!accessToken) {
      return { isConnected: false };
    }

    try {
      const dbx = new Dropbox({ accessToken });
      const account = await dbx.usersGetCurrentAccount();

      return {
        isConnected: true,
        accountEmail: account.result.email,
        lastExport: this.lastExportTimestamp
      };
    } catch {
      return { isConnected: false };
    }
  }

  async exportBackup(password: string): Promise<DropboxExportResult> {
    const accessToken = await getValidAccessToken();
    if (!accessToken) {
      return { success: false, error: 'Nicht mit Dropbox verbunden' };
    }

    try {
      // Collect all data (same as backup-service)
      const episodes = await db.episodes.toArray();
      const garminData = await db.garminData.toArray();
      const weatherData = await db.weatherData.toArray();
      const settings = await db.settings.toArray();

      const backupData: BackupData = {
        version: '1.0.0',
        createdAt: new Date().toISOString(),
        episodes,
        garminData,
        settings,
      };

      // Encrypt the backup
      const encrypted = await encryptData(JSON.stringify(backupData), password);

      // Create the encrypted backup wrapper (same format as local backups)
      const encryptedBackup = {
        version: '1.0.0',
        encrypted: true,
        algorithm: 'AES-GCM',
        iv: encrypted.iv,
        data: encrypted.data,
        exportedAt: new Date().toISOString(),
        source: 'dropbox-auto-export'
      };

      const fileContent = JSON.stringify(encryptedBackup, null, 2);
      const timestamp = format(new Date(), 'yyyy-MM-dd_HH-mm');
      const path = `/MigraineTracker/backup-${timestamp}.enc`;

      // Upload to Dropbox
      const dbx = new Dropbox({ accessToken });
      await dbx.filesUpload({
        path,
        contents: fileContent,
        mode: { '.tag': 'add' }, // Don't overwrite, create new file
        autorename: true
      });

      this.lastExportTimestamp = new Date().toISOString();

      return {
        success: true,
        path,
        timestamp: this.lastExportTimestamp
      };
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Export fehlgeschlagen';
      return { success: false, error: message };
    }
  }

  async isConnected(): Promise<boolean> {
    const status = await this.getConnectionStatus();
    return status.isConnected;
  }
}

export const dropboxClient = new DropboxClient();
```

2. Update `src/lib/dropbox/index.ts` to export everything:
```typescript
export * from './types';
export * from './constants';
export * from './auth';
export { dropboxClient } from './client';
```
  </action>
  <verify>npm run build passes, dropboxClient singleton available</verify>
  <done>Dropbox client with encrypted upload implemented, exports working</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npm run lint` passes
- [ ] Dependencies installed: `dropbox`, `@capacitor-community/generic-oauth2`
- [ ] All files in src/lib/dropbox/ compile correctly
- [ ] AndroidManifest.xml updated with OAuth callback intent-filter
</verification>

<success_criteria>

- Dependencies installed and synced with Capacitor
- Dropbox service layer created following existing patterns
- OAuth2 PKCE authentication implemented
- Encrypted file upload to Dropbox working
- No TypeScript or build errors
</success_criteria>

<output>
After completion, create `.planning/phases/09-dropbox-export/09-01-SUMMARY.md`
</output>
